from typing import Dict
from homeassistant.components.switch import SwitchEntity
from .device import HIVIDevice, SlaveDeviceInfo
from .const import DOMAIN, DEVICE_RELATION_CHANGED
from homeassistant.helpers.dispatcher import async_dispatcher_send
from homeassistant.helpers.restore_state import RestoreEntity
from .device import ConnectionStatus
from homeassistant.core import HomeAssistant
from homeassistant.config_entries import ConfigEntry
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from .device_manager import HIVIDeviceManager
import logging
from homeassistant.exceptions import HomeAssistantError
from homeassistant.helpers.entity import EntityCategory

_LOGGER = logging.getLogger(__name__)

# async def async_setup_entry(
#     hass: HomeAssistant,
#     config_entry: ConfigEntry,
#     async_add_entities: AddEntitiesCallback,
# ) -> None:
#     """Set up switch platform"""
#     device_manager: HIVIDeviceManager = hass.data[DOMAIN][config_entry.entry_id][
#         "device_manager"
#     ]

#     # Set up callback
#     device_manager.set_add_entities_callback("switch", async_add_entities)

#     # Initially add buttons for existing devices
#     entities = []
#     for device in device_manager.registry.devices.values():
#         entity = HIVISlaveControlSwitch(device, device_manager)
#         entities.append(entity)

#     if entities:
#         async_add_entities(entities, update_before_add=True)


class HIVISlaveControlSwitchHub:
    def __init__(self, hass, entry):
        self.hass = hass
        self.entry = entry
        self.switches = {}

    def get_switch(self, unique_id: str):
        return self.switches.get(unique_id)

    def add_switch(self, switch):
        self.switches[switch.unique_id] = switch


class HIVISlaveControlSwitch(SwitchEntity):
    """Control whether other speakers are set as slave speakers of the current speaker"""

    def __init__(
        self,
        hass: HomeAssistant,
        hub: HIVISlaveControlSwitchHub,
        master_speaker_device_id: str,
        slave_speaker_device_id: str,
        device_manager: HIVIDeviceManager,
        create_type: str = "standalone",
    ):
        """Initialize

        Args:
            master_device: Master speaker device
            slave_device: Slave speaker device
            device_manager: Device manager
        """
        self.hass = hass
        self._hub = hub
        self._master_speaker_device_id = master_speaker_device_id
        self._slave_speaker_device_id = slave_speaker_device_id
        self._device_manager = device_manager

        self._slave_device_friendly_name = self.get_slave_device_friendly_name(
            create_type
        )
        # Entity attributes
        self._attr_name = f"{self._slave_device_friendly_name} Play in sync"
        self._attr_unique_id = (
            f"{master_speaker_device_id}_slave_{slave_speaker_device_id}"
        )
        self._attr_device_info = {
            "identifiers": {(DOMAIN, master_speaker_device_id)},
        }
        self._attr_entity_category = EntityCategory.CONFIG

        # # Initial state: ON if the slave device is already a slave of this master device
        # self._attr_is_on = (
        #     slave_device.master_speaker_device_id == master_device.speaker_device_id
        # )

        self._hub.add_switch(self)

        async def device_registry_updated(event):
            _LOGGER.debug("Device registry updated event: %s", event.data)
            ha_device_id = event.data["device_id"]
            action = event.data["action"]
            if action == "remove":
                # Device deleted - delete current switch if slave device is removed
                slave_device_dict = self._device_manager.device_data_registry.get_device_dict_by_ha_device_id(
                    ha_device_id=ha_device_id
                )
                if slave_device_dict is not None:
                    speaker_device_id = slave_device_dict.get("speaker_device_id")
                    if speaker_device_id == self._slave_speaker_device_id:
                        _LOGGER.debug(
                            "Removing switch entity for deleted slave device %s",
                            speaker_device_id,
                        )
                        # Remove from hub
                        self._hub.switches.pop(self._attr_unique_id, None)
                        # Remove entity from Home Assistant
                        if self.hass and hasattr(self, "async_remove"):
                            await self.async_remove()

        self.hass.bus.async_listen("device_registry_updated", device_registry_updated)

    def get_master_device(self):
        """Get master and slave device objects"""
        master_device_dict = self._device_manager.device_data_registry.get_device_dict_by_speaker_device_id(
            self._master_speaker_device_id
        )
        if master_device_dict is None:
            _LOGGER.warning(
                f"Cannot find master device {self._master_speaker_device_id}"
            )
            return None

        master_device = HIVIDevice(**master_device_dict)

        return master_device

    def get_slave_device_friendly_name(self, create_type: str) -> str:
        """Get friendly name of slave device"""
        master_device = self.get_master_device()
        slave_device_friendly_name = ""
        if create_type == "from_standalone_device":
            slave_device_dict = self._device_manager.device_data_registry.get_device_dict_by_speaker_device_id(
                self._slave_speaker_device_id
            )
            if slave_device_dict is not None:
                slave_device = HIVIDevice(**slave_device_dict)
                slave_device_friendly_name = slave_device.friendly_name
            else:
                _LOGGER.error(
                    f"Cannot find information for slave device {self._slave_speaker_device_id}"
                )

        elif create_type == "from_slave_device":
            slave_device_list = master_device.slave_device_list
            for device_info in slave_device_list:
                if device_info.uuid == self._slave_speaker_device_id:
                    slave_device_friendly_name = device_info.friendly_name
                    break
            else:
                _LOGGER.error(
                    f"Cannot find information for slave device {self._slave_speaker_device_id} in the slave device list of master device {master_device.friendly_name}"
                )

        return slave_device_friendly_name

    def get_slave_device_ip_addr_by_standalone(self) -> str:
        """Get IP address of slave device"""
        slave_device_ip_addr = None

        slave_device_dict = self._device_manager.device_data_registry.get_device_dict_by_speaker_device_id(
            self._slave_speaker_device_id
        )
        if slave_device_dict is not None:
            slave_device = HIVIDevice(**slave_device_dict)
            slave_device_ip_addr = slave_device.ip_addr
        else:
            _LOGGER.error(
                f"Cannot find information for slave device {self._slave_speaker_device_id}"
            )

        return slave_device_ip_addr

    def get_slave_device_ip_addr_by_slave(self) -> str:
        """Get IP address of slave device"""
        slave_device_ip_addr = None

        master_device = self.get_master_device()
        slave_device_list = master_device.slave_device_list
        if slave_device_list is None:
            _LOGGER.error(
                f"Slave device list of master device {master_device.friendly_name} is empty"
            )
            return None
        for device_info in slave_device_list:
            if device_info.uuid == self._slave_speaker_device_id:
                slave_device_ip_addr = device_info.ip_addr
                break
        else:
            _LOGGER.error(
                f"Cannot find information for slave device {self._slave_speaker_device_id} in the slave device list of master device {master_device.friendly_name}"
            )

        return slave_device_ip_addr

    async def async_added_to_hass(self):
        """When entity is added to hass"""

        _LOGGER.debug(f"Adding switch entity {self.name} to Home Assistant")

        await super().async_added_to_hass()

        pass

        # # 1. Restore basic state from RestoreEntity
        # last_state = await self.async_get_last_state()
        # if last_state is not None:
        #     _LOGGER.debug(f"Restoring state for {self.name}: {last_state.state}")
        #     self._attr_is_on = last_state.state == "on"
        #     # Restore attributes
        #     if "use_count" in last_state.attributes:
        #         self._use_count = last_state.attributes["use_count"]
        #     if "last_action" in last_state.attributes:
        #         self._last_action = last_state.attributes["last_action"]

        # # # 2. Load additional data from custom storage
        # # stored_data = await self._store.async_load()
        # # if stored_data:
        # #     _LOGGER.debug(f"Loaded additional data for {self.name}")
        # #     # Load other data from storage

    @property
    def available(self) -> bool:
        """Whether the switch is available"""
        master_device = self.get_master_device()
        return (
            master_device.connection_status == ConnectionStatus.ONLINE
            and master_device.can_be_master
        )

    # @property
    # def is_on(self) -> bool:
    #     return self.is_on

    def on_off_switch(self, is_on: bool):
        """Enable or disable the switch

        Args:
            is_on: True for on, False for off
        """
        if self._attr_is_on != is_on:
            self._attr_is_on = is_on
            # Notify Home Assistant to update state
            if self.hass and hasattr(self, "async_write_ha_state"):
                self.async_write_ha_state()

            _LOGGER.debug(
                "Switch %s state set to: %s", self._attr_name, "ON" if is_on else "OFF"
            )

    @property
    def master_device(self) -> HIVIDevice:
        """Get master device object"""
        return self._master

    @property
    def slave_device(self) -> HIVIDevice:
        """Get slave device object"""
        return self._slave

    async def async_turn_on(self, **kwargs):
        """Turn on the switch - set master-slave relationship"""
        master_device = self.get_master_device()
        _LOGGER.debug(
            "Setting device %s as slave of device %s",
            self._slave_device_friendly_name,
            master_device.friendly_name,
        )
        self._attr_is_on = True
        # success = self._device_manager.registry.set_master_slave_relation(
        #     self._master.speaker_device_id, self._slave.speaker_device_id, True
        # )

        # if success:
        #     self._attr_is_on = True
        #     self.async_write_ha_state()

        #     # Trigger entity update
        #     async_dispatcher_send(self.hass, DEVICE_RELATION_CHANGED)

        async def operation_callback(result: Dict):
            """Operation callback function"""
            _LOGGER.debug("sync_group_operation turn on result: %s", result)
            need_refresh_flg = False
            if result.get("status") in [
                "rejected",
            ]:
                self._attr_is_on = False
            elif result.get("status") in [
                "accepted",
            ]:
                await self.hass.services.async_call(
                    DOMAIN, "postpone_discovery", {}, blocking=False
                )
            elif result.get("status") in [
                "executing",
                "verifying",
            ]:
                # _LOGGER.debug(
                #     "no need to refresh yet, status: %s", result.get("status")
                # )
                pass
            elif result.get("status") in ["success"]:
                need_refresh_flg = True
                _LOGGER.debug("need to refresh, status: %s", result.get("status"))
            elif result.get("status") in [
                "execution_failed",
                "error",
                "timeout",
                "max_retries_exceeded",
                "cancelled",
                "polling_error",
            ]:
                self._attr_is_on = False
                need_refresh_flg = True
                _LOGGER.debug("need to refresh, status: %s", result.get("status"))

            if need_refresh_flg:
                await self.hass.services.async_call(
                    DOMAIN, "refresh_discovery", {}, blocking=False
                )

            self.async_write_ha_state()

        slave_device_ip_addr = self.get_slave_device_ip_addr_by_standalone()
        if slave_device_ip_addr is None:
            _LOGGER.error(
                "Cannot find IP address of slave device %s, failed to set master-slave relationship",
                self._slave_device_friendly_name,
            )
            self._attr_is_on = False
            self.async_write_ha_state()
            return

        master_device = self.get_master_device()

        # Prepare operation data
        slave_ip = slave_device_ip_addr
        ssid = master_device.ssid
        wifi_channel = master_device.wifi_channel
        auth = master_device.auth_mode
        encry = master_device.encryption_mode
        psk = master_device.psk
        master_ip = master_device.ip_addr
        uuid = master_device.uuid
        operation_data = {
            "type": "set_slave",
            "master": self._master_speaker_device_id,
            "slave": self._slave_speaker_device_id,
            "expected_state": "slave",
            "params": {
                "slave_ip": slave_ip,
                "ssid": ssid,
                "wifi_channel": wifi_channel,
                "auth": auth,
                "encry": encry,
                "psk": psk,
                "master_ip": master_ip,
                "uuid": uuid,
            },
        }

        # Send request via dispatcher (requires corresponding receiver support)
        async_dispatcher_send(
            self.hass,
            f"{DOMAIN}_sync_group_operation",
            operation_data,
            operation_callback,  # Pass callback function
        )

    async def async_turn_off(self, **kwargs):
        """Turn off the switch - remove master-slave relationship"""
        master_device = self.get_master_device()
        self._attr_is_on = False

        _LOGGER.debug(
            "Removing device %s as slave of device %s",
            self._slave_device_friendly_name,
            master_device.friendly_name,
        )

        # success = self._device_manager.registry.set_master_slave_relation(
        #     self._master.speaker_device_id, self._slave.speaker_device_id, False
        # )

        # if success:
        #     self._attr_is_on = False
        #     self.async_write_ha_state()

        #     # Trigger entity update
        #     async_dispatcher_send(self.hass, DEVICE_RELATION_CHANGED)

        async def operation_callback(result: Dict):
            """Operation callback function"""
            _LOGGER.debug("sync_group_operation turn on result: %s", result)
            need_refresh_flg = False
            if result.get("status") in [
                "rejected",
            ]:
                self._attr_is_on = True
            elif result.get("status") in [
                "accepted",
            ]:
                await self.hass.services.async_call(
                    DOMAIN, "postpone_discovery", {}, blocking=False
                )
            elif result.get("status") in [
                "executing",
                "verifying",
            ]:
                # _LOGGER.debug(
                #     "no need to refresh yet, status: %s", result.get("status")
                # )
                pass
            elif result.get("status") in [
                "execution_failed",
                "error",
                "timeout",
                "max_retries_exceeded",
                "success",
                "cancelled",
                "polling_error",
            ]:
                need_refresh_flg = True
                _LOGGER.debug("need to refresh, status: %s", result.get("status"))

            if need_refresh_flg:
                await self.hass.services.async_call(
                    DOMAIN, "refresh_discovery", {}, blocking=False
                )

            self.async_write_ha_state()

        slave_ip_ra0 = self.get_slave_device_ip_addr_by_slave()

        if slave_ip_ra0 is None:
            _LOGGER.error(
                "Cannot find IP address of slave device %s, failed to remove master-slave relationship",
                self._slave_device_friendly_name,
            )
            self._attr_is_on = True
            self.async_write_ha_state()
            return
        operation_data = {
            "type": "remove_slave",
            "master": self._master_speaker_device_id,
            "slave": self._slave_speaker_device_id,
            "expected_state": "standalone",
            "params": {
                "master_ip": master_device.ip_addr,
                "slave_ip_ra0": slave_ip_ra0,
            },
        }

        # Send request via dispatcher (requires corresponding receiver support)
        async_dispatcher_send(
            self.hass,
            f"{DOMAIN}_sync_group_operation",
            operation_data,
            operation_callback,  # Pass callback function
        )

    @property
    def extra_state_attributes(self):
        """Extra state attributes"""
        master_device = self.get_master_device()
        return {
            "master_device": master_device.speaker_device_id,
            "slave_device": self._slave_speaker_device_id,
            "master_name": master_device.friendly_name,
            "slave_name": self._slave_device_friendly_name,
        }


async def async_setup_entry(hass, config_entry, async_add_entities):
    """Set up switch entities"""
    device_manager = hass.data[DOMAIN][config_entry.entry_id]["device_manager"]

    # Set up callback
    device_manager.set_add_entities_callback("switch", async_add_entities)

    # registry = device_manager.registry

    # switches = []

    # for master_device in registry.devices.values():
    #     if not master_device.can_be_master:
    #         continue

    #     # Create switches for master speaker to control other speakers
    #     for slave_candidate in registry.get_available_slaves(
    #         master_device.speaker_device_id
    #     ):
    #         switch = HIVISlaveControlSwitch(
    #             master_device, slave_candidate, device_manager
    #         )
    #         switches.append(switch)

    # async_add_entities(switches, update_before_add=True)
